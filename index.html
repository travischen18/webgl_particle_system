<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script>
			// Our Javascript will go here.
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

			var renderer = new THREE.WebGLRenderer();
			renderer.setClearColor(0x589b84);

			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			class Emitter {
				constructor() {
					this.geometry = new THREE.CircleGeometry(3);
					this.material = new THREE.LineBasicMaterial({color: 0x081e47});
					this.mesh = new THREE.Mesh(this.geometry, this.material);

					this.mesh.position.set(0, 10, -10);

					this.normal = new THREE.Vector3(0, 0, 1);
					this.normalLine = null;
					this.updateNormalLine();

					this.power = 10;
				}

				updateNormalLine() {
					var material = new THREE.LineBasicMaterial({
						color: 0xfbff26
					});

					var geometry = new THREE.Geometry();
					var n_line_end = new THREE.Vector3();
					n_line_end.addVectors(this.mesh.position, this.normal);

					geometry.vertices.push(
						this.mesh.position,
						n_line_end
					);

					this.normalLine = new THREE.Line(geometry, material);
				}

				rotateX(angle) {
					this.mesh.rotateX(angle);
					this.normal.applyAxisAngle(new THREE.Vector3(1, 0, 0), angle);
					console.log(this.normal);
					this.updateNormalLine();
				}

				rotateY(angle) {
					this.mesh.rotateY(angle);
					this.normal.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
					console.log(this.normal);
					this.updateNormalLine();
				}

				rotateZ(angle) {
					this.mesh.rotateZ(angle);
					this.normal.applyAxisAngle(new THREE.Vector3(0, 0, 1), angle);
					console.log(this.normal);
					this.updateNormalLine();
				}
			}

			class Particle {
				constructor(emitter) {
					this.geometry = new THREE.SphereGeometry(0.5,8,8);
					this.material = new THREE.MeshLambertMaterial({color: 0xfcf3d1});
					this.mesh = new THREE.Mesh(this.geometry, this.material);

					this.force = new THREE.Vector3(0, -9.81, 0);

					this.mesh.position.copy(emitter.mesh.position);
					this.velocity = emitter.normal.clone();
					this.velocity.multiplyScalar(emitter.power);
					this.mass = 1;
				}

				updatePosition() {
					var dp = new THREE.Vector3(0, 0, 0);
					dp.addScaledVector(this.velocity, 0.01);

					this.mesh.position.add(dp);
				}

				updateVelocity(Collider) {

					if (this.isCollided(Collider)) {
						var k = 0.5
						var a = 0.5

						var v1 = new THREE.Vector3(0, 0, 0);
						var v_dot_n = this.velocity.dot(Collider.normal);

						var v_n = Collider.normal.clone();
						v_n.multiplyScalar(v_dot_n);

						var t_vec = this.velocity.clone();
						t_vec.sub(v_n);
						t_vec.multiplyScalar(a);

						var n_vec = v_n.clone();
						n_vec.multiplyScalar(k);

						this.velocity.subVectors(t_vec, n_vec);

					} else {
						var dv = new THREE.Vector3(0, 0, 0);
						dv.addScaledVector(this.force, 0.01);

						this.velocity.add(dv);
					}
					
				}

				isCollided(Collider) {
					var xp = new THREE.Vector3(0, 0, 0);

					// set xp = x - p
					xp.subVectors(this.mesh.position, Collider.getPosition());

					var dp = xp.dot(Collider.normal);
					var v_dir = this.velocity.dot(Collider.normal);

					if (inColliderBounds(Collider)) {

					}

					if (dp > -0.1 && dp < 0.1 && v_dir < 0) {
						return true;
					}

					return false;
				}

				// plane collider
				inColliderBounds(Collider) {

				}
			}

			class PlaneCollider {
				constructor() {
					this.geometry = new THREE.PlaneGeometry(20, 20);
					this.material = new THREE.MeshLambertMaterial({color: 0x799ad1});
					this.mesh = new THREE.Mesh(this.geometry, this.material);

					this.normal = new THREE.Vector3(0, 1, 0);

					this.mesh.position.set(0, 0, 0);
					this.mesh.rotateX(-1.57);
				}

				getPosition() {
					return this.mesh.position;
				}

				setPosition(x, y, z) {
					this.mesh.position.set(x, y, z);
				}

				getHeight() {
					return this.geometry.parameters["height"];
				}

				getWidth() {
					return this.geometry.parameters["width"];
				}

				rotate() {
				}
			}

			var light = new THREE.PointLight(0xffffff, 2, 50);
			light.position.set(2, 10, 3);

			var a_light = new THREE.AmbientLight(0x404040, 2);
			scene.add(a_light);

			scene.add(light);

			var plane = new PlaneCollider();
			plane.setPosition(0, -5, 0);
			scene.add(plane.mesh);

			var emitter = new Emitter();
			scene.add(emitter.mesh);

			//scene.add(emitter.normalLine);

			//emitter.rotateZ(1.57);

			camera.position.z = 20;
			camera.position.x = -10;
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			var particles = [];

			var intervalID = window.setInterval(addParticle, 500);

			function addParticle() {
				if (particles.length < 50) {
					particles.push(new Particle(emitter));
					scene.add(particles[particles.length - 1].mesh);
				}
			}

			function animate() {
				requestAnimationFrame(animate);

				for (var i = 0; i < particles.length; i++) {
					particles[i].updateVelocity(plane);
					particles[i].updatePosition();
				}

				renderer.render(scene, camera);
			}
			animate();
		</script>
	</body>
</html>